/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace Leap {

public class Vector : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  public Vector(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  public static global::System.Runtime.InteropServices.HandleRef getCPtr(Vector obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~Vector() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          LeapPINVOKE.delete_Vector(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

  /** Add vectors component-wise. */
  public static Vector operator + (Vector v1, Vector v2) {
    return v1._operator_add(v2);
  }
  /** Subtract vectors component-wise. */
  public static Vector operator - (Vector v1, Vector v2) {
    return v1._operator_sub(v2);
  }
  /** Multiply vector by a scalar. */
  public static Vector operator * (Vector v1, float scalar) {
    return v1._operator_mul(scalar);
  }
  /** Multiply vector by a scalar on the left-hand side. */
  public static Vector operator * (float scalar, Vector v1) {
    return v1._operator_mul(scalar);
  }
  /** Divide vector by a scalar. */
  public static Vector operator / (Vector v1, float scalar) {
    return v1._operator_div(scalar);
  }
  /** Negate a vector. */
  public static Vector operator - (Vector v1) {
    return v1._operator_sub();
  }
  /** Convert this vector to an array of three float values: [x,y,z]. */
  public float[] ToFloatArray() {
    return new float[] {x, y, z};
  }

  public Vector() : this(LeapPINVOKE.new_Vector__SWIG_0(), true) {
  }

  public Vector(float _x, float _y, float _z) : this(LeapPINVOKE.new_Vector__SWIG_1(_x, _y, _z), true) {
  }

  public Vector(Vector vector) : this(LeapPINVOKE.new_Vector__SWIG_2(Vector.getCPtr(vector)), true) {
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
  }

  public float DistanceTo(Vector other) {
    float ret = LeapPINVOKE.Vector_DistanceTo(swigCPtr, Vector.getCPtr(other));
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public float AngleTo(Vector other) {
    float ret = LeapPINVOKE.Vector_AngleTo(swigCPtr, Vector.getCPtr(other));
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public float Dot(Vector other) {
    float ret = LeapPINVOKE.Vector_Dot(swigCPtr, Vector.getCPtr(other));
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Vector Cross(Vector other) {
    Vector ret = new Vector(LeapPINVOKE.Vector_Cross(swigCPtr, Vector.getCPtr(other)), true);
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Vector _operator_sub() {
    Vector ret = new Vector(LeapPINVOKE.Vector__operator_sub__SWIG_0(swigCPtr), true);
    return ret;
  }

  private Vector _operator_add(Vector other) {
    Vector ret = new Vector(LeapPINVOKE.Vector__operator_add(swigCPtr, Vector.getCPtr(other)), true);
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Vector _operator_sub(Vector other) {
    Vector ret = new Vector(LeapPINVOKE.Vector__operator_sub__SWIG_1(swigCPtr, Vector.getCPtr(other)), true);
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private Vector _operator_mul(float scalar) {
    Vector ret = new Vector(LeapPINVOKE.Vector__operator_mul(swigCPtr, scalar), true);
    return ret;
  }

  private Vector _operator_div(float scalar) {
    Vector ret = new Vector(LeapPINVOKE.Vector__operator_div(swigCPtr, scalar), true);
    return ret;
  }

  public override string ToString() {
    string ret = LeapPINVOKE.Vector_ToString(swigCPtr);
    return ret;
  }

  public bool Equals(Vector other) {
    bool ret = LeapPINVOKE.Vector_Equals(swigCPtr, Vector.getCPtr(other));
    if (LeapPINVOKE.SWIGPendingException.Pending) throw LeapPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool IsValid() {
    bool ret = LeapPINVOKE.Vector_IsValid(swigCPtr);
    return ret;
  }

  private float _operator_get(uint index) {
    float ret = LeapPINVOKE.Vector__operator_get(swigCPtr, index);
    return ret;
  }

  public float x {
    set {
      LeapPINVOKE.Vector_x_set(swigCPtr, value);
    } 
    get {
      float ret = LeapPINVOKE.Vector_x_get(swigCPtr);
      return ret;
    } 
  }

  public float y {
    set {
      LeapPINVOKE.Vector_y_set(swigCPtr, value);
    } 
    get {
      float ret = LeapPINVOKE.Vector_y_get(swigCPtr);
      return ret;
    } 
  }

  public float z {
    set {
      LeapPINVOKE.Vector_z_set(swigCPtr, value);
    } 
    get {
      float ret = LeapPINVOKE.Vector_z_get(swigCPtr);
      return ret;
    } 
  }

  public float Magnitude {
    get {
      float ret = LeapPINVOKE.Vector_Magnitude_get(swigCPtr);
      return ret;
    } 
  }

  public float MagnitudeSquared {
    get {
      float ret = LeapPINVOKE.Vector_MagnitudeSquared_get(swigCPtr);
      return ret;
    } 
  }

  public float Pitch {
    get {
      float ret = LeapPINVOKE.Vector_Pitch_get(swigCPtr);
      return ret;
    } 
  }

  public float Roll {
    get {
      float ret = LeapPINVOKE.Vector_Roll_get(swigCPtr);
      return ret;
    } 
  }

  public float Yaw {
    get {
      float ret = LeapPINVOKE.Vector_Yaw_get(swigCPtr);
      return ret;
    } 
  }

  public Vector Normalized {
    get {
      global::System.IntPtr cPtr = LeapPINVOKE.Vector_Normalized_get(swigCPtr);
      Vector ret = (cPtr == global::System.IntPtr.Zero) ? null : new Vector(cPtr, true);
      return ret;
    } 
  }

  public static Vector Zero {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Zero_get(), false);
      return ret;
    } 
  }

  public static Vector XAxis {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_XAxis_get(), false);
      return ret;
    } 
  }

  public static Vector YAxis {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_YAxis_get(), false);
      return ret;
    } 
  }

  public static Vector ZAxis {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_ZAxis_get(), false);
      return ret;
    } 
  }

  public static Vector Forward {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Forward_get(), false);
      return ret;
    } 
  }

  public static Vector Backward {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Backward_get(), false);
      return ret;
    } 
  }

  public static Vector Left {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Left_get(), false);
      return ret;
    } 
  }

  public static Vector Right {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Right_get(), false);
      return ret;
    } 
  }

  public static Vector Up {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Up_get(), false);
      return ret;
    } 
  }

  public static Vector Down {
    get {
      Vector ret = new Vector(LeapPINVOKE.Vector_Down_get(), false);
      return ret;
    } 
  }

}

}
